10/18
<개발 환경설정>

	<-
server	->	DB

jpa
hibernate: DB와 내 서버를 쉽게 연결시켜 줌
약속된 형태로만 사용
순서가 바뀌면 무조건 문제가 생김
굉장히 꼼꼼, 민감함게 작업 필요

1. 약속된 형태 사용
2. 코드 순서 체크

(메이븐?)

생성자 만들어짐
public or protected
-> protected로 설정 만들어짐


(private 는 싱글톤만)

Entity
(like 유저라는 ㅌ생성)

회사마다 약속된 @Table 이름이 있다.

Entity 와 Table =jpa 사용?
(implementation "org.springframework.boot:spring-boot-starter-data-jpa")

Getter&NoArgsConstructor = 롬복

-

해당 필드의 널 값으로 쓸 수 없게 설정 = 비워 둘 수 없다.

-

User 라는 클래스 테이블 내부에서
이름을 설정하면 45 이내로 

jpa 쓰는 이유?
작업량이 매우 많은데
쓰면 기본작업들이 편리해지니까 

유일하게 하나만 존재할 수 있게 만드는 키워드
중복 될 수 없어 = 이 테이블 안에는 중복 될 수 없어 값이
(이름에다는 쓸 수 없으니까 이메일에다가 만듦)

나이/ 생년월일 / 주소 등등 뒤에 붙여서 만듦

복사생성자 builder
인자는 매번 사용될거고 매번 바뀔거니까 
거의 매번 사용된다고 봐야함


컨트롤러에서 리포지토리를 바로 만들 수 ㄴ 없어

컨트롤러
↑↓
서비스 
↑↓
리포지토리

일반 컨트롤러 X
RestController 사용한 영상물을 참고해서 사용


유저 테이블에 저장은 되어야 하지만
join에서 필요한 데이터는 ex) id pw 두개밖에 없으므로
실제로는 유저 디티오를 

디티오에서 필드 값이 존재한다고 하더라도

게터
널값을 가져와서 참조는 말이 안됨

필요한 위치에 적정 필드 값만 있으면 좋겠는데
필요하지 않은 값도 같이 불러와지면 효율도, 실수도 발생가능

클래스에다가 또 다른 (내부)클래스를 만들어 그때 그때
필요한걸 호출 해서 사용

유저 로그인할 때만 쓰는 Dto


final 써두면 알아서 적용 해줌

계층 구조 무조건 demoApplication 즉 main 아래에 다 넣어놔야함 패키지, 클래스등
그래야 정상 작동 됨

이메일이 있는지 없는지 확인하고!
ㅅ
<- 내 DB에 이멜이 없는데 백날 로그인 해봐야 소용X 이므로


SQL은 무조건 데이터의 형태로만 되어있음
행과 열로 이루어져 있음

관계지향형 = DB에 초점 == sql
객체지향형 <= 으로 바꿔주면 좋겠다(class) = jpa가
그래서 Entity
여기안에다 데이터를 맵핑 시켜줘

jpa가 엔티티를 찾았을 때 그 데이터를 바꿔줘? 요
그래서 String findByEmail을 그냥 User findByEmail로도 써서 불러올 수 있음 
그냥 유저의 겟 이메일, 겟 네임 등등

(원래는 User에 나이는 나이 이메일은 이메일 이런식으로 맵핑을 해야지만
객체지향형 코드로 쓸 수 있음 = Entity를 사용하는 이유)

jpa가 엔티티를 인지해서 그 안에 User 엔티티를 확인해서 맵핑해서
우리에게 반환 해줌

jpa =  (관계지향형 - 객체지향형) 의 연결고리
패러다임의 불일치를 해결 해준 것.

여전히 불일치는 남아 있지만 해소만 해줌
-----------------
 
sql 은 데이터로만 남아있기 때문에 클래스로 사용X
엔티티 덕ㄷ분에 데이터 -> 클래스

-----------

리턴 값이 있다면 마지막으로 실행되는 위치가 어디냐만 생각! 그 위치로 가서 리턴값이 전달이 됨
 리턴 값이 있으면 그 값을 가지고 가고 없으면 걍 감










