10/23

서비스 - 로그인 함수

유저 컨트롤러 에서
로그인 하려면 토큰을 같이 꼽아서 보내야 함
인증작업을 거치고 완료된 인증은 

return ResponseEntity.ok().header("Authorization", "Bearer "+jwt)
                .body(ApiUtils.success(null));

("Authorization", "Bearer "+jwt) 부분
== -H "Authorization: Bearer ${ACCESS_TOKEN}"

---
401 페이지가 아무것도 안뜨는 상태
대응이 안되는 상태



--
문제가 났을 때 예외처리를 생각해줘야 함
404가 그냥 뜨는거랑
내가 보냈을 때랑 다름 = 대응 가능

* 예외 클래스, 핸들러 중요 


--
@Bean
스트링에 Bean이라는 객체 상태를 등록 하겠다
빈등록이 되면 자동으로 뭔가가 시작된다.
실행을 직접하는게 아니라 알아서 시작되는 개념

암호화를 하려면
Key가 필요
안정성을 위해 보통은 키를 랜덤값으로 설정함

복호화
암호화 된 걸 다시 되돌리는 작업
키를 알고 있으면..?
로그인 될 때 확인 필요 하니까?

암호화를 하고 -> 복호화 -> 다시 암호화 -> 돌돌

시큐리티 안에 다양한 알고리즘이 있는데
어떤 알고리즘을 설정할 것이냐 도 해줘야하고

시큐리티 매니저도 만들어야함 = 여러가지 설정값이 필요

---
동명이인이나 뭔가 있을 수 있음
한명만 있어야 하는데 여러명일 수 있으니까
반드시 보낼 때는 PK일 수 있는 (값)형태를 보내줘야 함
유저의 값을 검증작업 진행

--
인증을 어떻게 하든 간에
인증 값을 먼저 써줌

--
유저가 만약 회원 가입을 했는데 그 회원가입을 한애가 어떤 애냐
= 권한이 있어야 함 = 권한 설정

관리자도 등급이 있을 수 있음
= 최종 관리자
= 개발 관리자
= admin 관리자(직원) ex) 매출 관리, 제품 관리

어드민이면서 매니저일 수 있음

관리자 권한이 한개가 아니라 여러개 일 수 있어서 List 넣어줌


DB에서 들고오면 리스트로 만들어 주는 거
Entity -> DB로 갈땐 하나의 문자열로 만드는 거

다시 넘어올 땐 리스트여야하고

패러다임의 불일치 때문에 반드시 해줘야하는 과정


--
결국엔 save 과정
--
"SECRET_KEY" 아마 회사마다 요구하는 이름이 다를 것
--
TOKEN_PREFIX + HEADER
묶어서
토큰을..줄건데
create
사용된 위치 - 

--
인터페이스를 사용할 때는 
이미 구현할 메서드가 있다..

--
요청을 받아서 처리 하는데

요청을 했을ㄸ대
// ** 헤더
    public static final String HEADER = "Authorization";
가 없을 수도 있지.. -> if null~

Algorithm.HMAC512(SECRET)
암호화한 키..
기준으로 들어온 String jwt 검증

--
원래 모든 test는 구조적으로 다 짜줘야 함
table 많아질수록..

--
유저 리퀘스트
회원가입 DTO
로그인 DTO는 그때그때 또 따로 필요 함




